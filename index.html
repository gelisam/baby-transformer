<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TensorFlow.js Linear Regression</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        #status {
            margin: 20px 0;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
        }
        canvas {
            border: 1px solid #ddd;
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        .results {
            margin-top: 20px;
            padding: 15px;
            background-color: #e7f3fe;
            border-left: 4px solid #2196F3;
        }
    </style>
</head>
<body>
    <h1>TensorFlow.js Linear Regression Demo</h1>
    <p>This example trains a simple linear regression model to learn y = 2x - 1</p>
    
    <button onclick="trainModel()">Train Model</button>
    
    <div id="status">Click the button to start training...</div>
    
    <div id="results" class="results" style="display: none;">
        <h3>Results:</h3>
        <p><strong>Target equation:</strong> y = 2x - 1</p>
        <p><strong>Learned parameters:</strong></p>
        <p id="params"></p>
        <p id="predictions"></p>
    </div>
    
    <canvas id="canvas" width="600" height="400"></canvas>

    <script>
        // Define the model
        function createModel() {
            const model = tf.sequential();
            
            // Add a single dense layer with 1 unit (output)
            // This creates a linear model: y = mx + b
            model.add(tf.layers.dense({
                units: 1,
                inputShape: [1]
            }));
            
            // Compile the model with mean squared error loss
            model.compile({
                loss: 'meanSquaredError',
                optimizer: tf.train.sgd(0.1) // Stochastic Gradient Descent with learning rate 0.1
            });
            
            return model;
        }

        // Generate training data for y = 2x - 1
        function generateData() {
            const xs = [];
            const ys = [];
            
            // Create 100 training examples
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 10 - 5; // Random values between -5 and 5
                const y = 2 * x - 1; // True relationship
                xs.push(x);
                ys.push(y);
            }
            
            // Convert to tensors
            const xsTensor = tf.tensor2d(xs, [xs.length, 1]);
            const ysTensor = tf.tensor2d(ys, [ys.length, 1]);
            
            return { xs: xsTensor, ys: ysTensor, xsArray: xs, ysArray: ys };
        }

        // Train the model
        async function trainModel() {
            document.getElementById('status').innerHTML = 'Training model...';
            document.getElementById('results').style.display = 'none';
            
            // Create model
            const model = createModel();
            
            // Generate data
            const data = generateData();
            
            // Train the model
            await model.fit(data.xs, data.ys, {
                epochs: 100,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        if (epoch % 10 === 0) {
                            document.getElementById('status').innerHTML = 
                                `Training... Epoch ${epoch}/100 - Loss: ${logs.loss.toFixed(4)}`;
                        }
                    }
                }
            });
            
            // Get the learned parameters
            const weights = model.getWeights();
            const slope = weights[0].dataSync()[0];
            const intercept = weights[1].dataSync()[0];
            
            // Make predictions
            const testX = tf.tensor2d([0, 1, 2, 3, 4], [5, 1]);
            const predictions = model.predict(testX);
            const predArray = await predictions.array();
            
            // Display results
            document.getElementById('status').innerHTML = 'Training complete!';
            document.getElementById('results').style.display = 'block';
            document.getElementById('params').innerHTML = 
                `y = ${slope.toFixed(4)}x + ${intercept.toFixed(4)}`;
            
            let predText = '<strong>Sample predictions:</strong><br>';
            for (let i = 0; i < 5; i++) {
                predText += `x = ${i}, predicted y = ${predArray[i][0].toFixed(4)}, actual y = ${2 * i - 1}<br>`;
            }
            document.getElementById('predictions').innerHTML = predText;
            
            // Visualize
            visualize(data.xsArray, data.ysArray, slope, intercept);
            
            // Clean up tensors
            data.xs.dispose();
            data.ys.dispose();
            testX.dispose();
            predictions.dispose();
        }

        // Visualize the data and learned model
        function visualize(xs, ys, slope, intercept) {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Find data range
            const xMin = -5;
            const xMax = 5;
            const yMin = -15;
            const yMax = 15;
            
            // Helper function to convert data coordinates to canvas coordinates
            function toCanvasX(x) {
                return ((x - xMin) / (xMax - xMin)) * (canvas.width - 60) + 30;
            }
            
            function toCanvasY(y) {
                return canvas.height - 30 - ((y - yMin) / (yMax - yMin)) * (canvas.height - 60);
            }
            
            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(30, canvas.height - 30);
            ctx.lineTo(canvas.width - 30, canvas.height - 30);
            ctx.moveTo(30, 30);
            ctx.lineTo(30, canvas.height - 30);
            ctx.stroke();
            
            // Draw data points
            ctx.fillStyle = 'blue';
            for (let i = 0; i < xs.length; i++) {
                ctx.beginPath();
                ctx.arc(toCanvasX(xs[i]), toCanvasY(ys[i]), 3, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Draw learned line
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toCanvasX(xMin), toCanvasY(slope * xMin + intercept));
            ctx.lineTo(toCanvasX(xMax), toCanvasY(slope * xMax + intercept));
            ctx.stroke();
            
            // Draw true line (green, dashed)
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(toCanvasX(xMin), toCanvasY(2 * xMin - 1));
            ctx.lineTo(toCanvasX(xMax), toCanvasY(2 * xMax - 1));
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Add legend
            ctx.font = '14px Arial';
            ctx.fillStyle = 'blue';
            ctx.fillText('● Training data', canvas.width - 150, 20);
            ctx.fillStyle = 'red';
            ctx.fillText('— Learned model', canvas.width - 150, 40);
            ctx.fillStyle = 'green';
            ctx.fillText('- - True model (y=2x-1)', canvas.width - 200, 60);
        }
    </script>
</body>
</html>
